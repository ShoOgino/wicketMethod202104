	/**
	 * Simulate what DateTimeField does
	 * 
	 * @param dateStr
	 * @param hours
	 * @param minutes
	 * @param amOrPm
	 * @param use12HourFormat
	 * @param tzClient
	 * @return Date
	 * @throws ParseException
	 */
	public Date convertDate(final String dateStr, final Integer hours, final Integer minutes,
		final AM_PM amOrPm, final boolean use12HourFormat, final TimeZone tzClient)
		throws ParseException
	{
		log.debug(">>> convertDate()");
		Date dateFieldInput = (dateStr != null ? DateFormat.getDateInstance().parse(dateStr) : null);

		// Default to today, if date entry was invisible
		final MutableDateTime date;
		if (dateFieldInput != null)
		{
			log.debug("1. dateFieldInput: " + dateFieldInput.getTime() + "  " + dateFieldInput);
			date = new MutableDateTime(dateFieldInput);
		}
		else
		{
			log.debug("1. dateFieldInput: null");
			// Current date
			date = new MutableDateTime();
		}
		log.debug("2. mutable date: " + date.getMillis() + "  " + date);

		// always set secs to 0
		date.setSecondOfMinute(0);
		log.debug("3. secs = 0: " + date.getMillis() + "  " + date);

		// The AM/PM field
		if (use12HourFormat)
		{
			date.set(DateTimeFieldType.halfdayOfDay(), amOrPm == AM_PM.PM ? 1 : 0);
		}
		log.debug("4. AM/PM: " + date.getMillis() + "  " + date);

		// The hours
		if (hours == null)
		{
			date.setHourOfDay(0);
		}
		else
		{
			date.set(DateTimeFieldType.hourOfDay(), hours % (use12HourFormat ? 12 : 24));
		}
		log.debug("5. hours: " + date.getMillis() + "  " + date);

		// The minutes
		if (minutes == null)
		{
			date.setMinuteOfHour(0);
		}
		else
		{
			date.setMinuteOfHour(minutes);
		}
		log.debug("6. minutes: " + date.getMillis() + "  " + date);

		// Use the client timezone to properly calculate the millisecs
		if (tzClient != null)
		{
			date.setZoneRetainFields(DateTimeZone.forTimeZone(tzClient));
			log.debug("7. zone: " + date.getMillis() + "  " + date);
		}

		Date rtn = new Date(date.getMillis());
		log.debug("8. final date: " + rtn.getTime() + "  " + rtn);
		return rtn;
	}

