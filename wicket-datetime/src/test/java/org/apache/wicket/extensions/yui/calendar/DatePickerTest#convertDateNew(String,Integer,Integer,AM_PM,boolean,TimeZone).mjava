	/**
	 * Simulate what DateTimeField does
	 * 
	 * @param dateStr
	 * @param hours
	 * @param minutes
	 * @param amOrPm
	 * @param use12HourFormat
	 * @param tzClient
	 * @return Date
	 * @throws ParseException
	 */
	private Date convertDateNew(final String dateStr, final Integer hours, final Integer minutes,
		final AM_PM amOrPm, final boolean use12HourFormat, final TimeZone tzClient)
		throws ParseException
	{
		log.debug(">>> convertDateNew()");
		// This is what I get from field.getConvertedInput()
		Date dateFieldInput = (dateStr != null ? DateFormat.getDateInstance().parse(dateStr) : null);

		// Default with "now"
		if (dateFieldInput == null)
		{
			dateFieldInput = new Date();
		}

		// Get year, month and day ignoring any timezone of the Date object
		Calendar cal = Calendar.getInstance();
		cal.setTime(dateFieldInput);
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH) + 1;
		int day = cal.get(Calendar.DAY_OF_MONTH);
		int iHours = (hours == null ? 0 : hours % 24);
		int iMins = (minutes == null ? 0 : minutes);

		// Use the input to create a date object with proper timezone
		MutableDateTime date = new MutableDateTime(year, month, day, iHours, iMins, 0, 0,
			DateTimeZone.forTimeZone(tzClient));

		// Use the input to create a date object. Ignore the timezone provided by dateFieldInput and
		// use tzClient instead. No re-calculation will happen. It should be the same as above.
// MutableDateTime date = new MutableDateTime(dateFieldInput,
// DateTimeZone.forTimeZone(tzClient));
		log.debug("1. date: " + date.getMillis() + "  " + date);

		// Adjust for halfday if needed
		int halfday;
		if (use12HourFormat)
		{
			halfday = (amOrPm == AM_PM.PM ? 1 : 0);
			date.set(DateTimeFieldType.halfdayOfDay(), halfday);
			date.set(DateTimeFieldType.hourOfDay(), iHours % 12);
		}
		log.debug("2. halfday adjustments: " + date.getMillis() + "  " + date);

		Date rtn = new Date(date.getMillis());
		log.debug("3. final date: " + rtn.getTime() + "  " + rtn);
		return rtn;
	}

