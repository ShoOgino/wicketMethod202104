	/**
	 * <p>
	 * Reads the <code>header-part</code> of the current
	 * <code>encapsulation</code>.
	 * <p>
	 * Headers are returned verbatim to the input stream, including the trailing
	 * <code>CRLF</code> marker. Parsing is left to the application.
	 * 
	 * @param maxSize
	 *            The maximum amount to read before giving up
	 * 
	 * @return The <code>header-part</code> of the current encapsulation.
	 * 
	 * @exception MalformedStreamException
	 *                if the stream ends unexpecetedly.
	 */
	public String readHeaders(final int maxSize) throws MalformedStreamException
	{
		int i = 0;
		byte[] b = new byte[1];
		// to support multi-byte characters
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		int sizeMax = HEADER_PART_SIZE_MAX;
		int size = 0;
		while (i < 4)
		{
			try
			{
				b[0] = readByte();
			}
			catch (IOException e)
			{
				throw new MalformedStreamException("Stream ended unexpectedly");
			}
			size++;
			if (size > maxSize)
			{
				throw new MalformedStreamException("Stream exceeded maximum of " + maxSize + " bytes");
			}
			if (b[0] == HEADER_SEPARATOR[i])
			{
				i++;
			}
			else
			{
				i = 0;
			}
			if (size <= sizeMax)
			{
				baos.write(b[0]);
			}
		}

		String headers = null;
		if (headerEncoding != null)
		{
			try
			{
				headers = baos.toString(headerEncoding);
			}
			catch (UnsupportedEncodingException e)
			{
				// Fall back to platform default if specified encoding is not
				// supported.
				headers = baos.toString();
			}
		}
		else
		{
			headers = baos.toString();
		}

		return headers;
	}

