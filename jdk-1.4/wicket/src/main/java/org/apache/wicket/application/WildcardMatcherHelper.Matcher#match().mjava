        /**
         * Scans the pattern and the search string from the start toward the end
         *
         * @return wether the pstring matches the pattern
         */
        private boolean match() {
            // scan a common literal prefix
            scanLiteralPrefix();

            // if we are already at the end of both strings 
            // than the pattern matched
            if(ipat >= lpat && istr >= lstr) return true;

            // if hole string has matched the pattern so far and the rest of the pattern only has wildcard(s)
            // we match too otherwise we clearly don't match
            if(ipat < lpat && istr >= lstr) {
                while(ipat < lpat && apat[ipat] == STAR) ipat++;

                if(ipat >= lpat) {
                    add("");

                    return true;
                } else {
                    return false;
                }
            }

            // if hole pattern has matched the string so far but the string has more characters left
            // we don't match
            if(ipat >= lpat && istr < lstr) return false;

            // if we have not stopped at a wildcard character 
            // a character doesn't match and thus we do not match at all
            if(apat[ipat] != STAR) return false;

            // if it is a double (or more) wildcard pattern
            if(ipat < lpat - 1 && apat[ipat + 1] == STAR) {
                // skip to first non star charater in the pattern
                while(++ipat < lpat && apat[ipat] == STAR);

                // if we are at the end of the pattern we've matched and are finish scanning
                if(ipat >= lpat) {
                    add(new String(astr, istr, lstr - istr));

                    return true;
                }

                // Now we need to scan for the end of the literal characters in the pattern
                final int sipat = ipat; // start position of a literal character used for substring operations

                while(ipat < lpat && (apat[ipat] != STAR || (ipat > 0 && apat[ipat - 1] == ESC))) ipat++;

                // if we reached the end of the pattern just do a string compare with the corresponding part from 
                // the end of the string
                if(ipat >= lpat) {
                    return checkEnds(sipat, false);
                }

                // Now we need to check whether the litteral substring of the pattern 
                // is contained in the string somewhere
                final int l = ipat - sipat;
                int eistr = lstr - l;

                // beause the '**' wildcard need to be greedy we scan from the end of the string for a match
                while(istr < eistr && ! strncmp(apat, sipat, astr, eistr, l)) eistr--;

                if(istr >= eistr) return false;

                add(new String(astr, istr, eistr - istr));
                istr = eistr + l;
            } else {// if it is a single star pattern
                // skip the star
                ++ipat;

                // if we are at the beginning of the pattern we have to check there is no PATH_SEP in string
                if(ipat >= lpat) {
                    final int sistr = istr;

                    while(istr < lstr && (astr[istr] != PATHSEP)) istr++;

                    if(istr >= lstr) {
                        add(new String(astr, sistr, lstr - sistr));

                        return true;
                    }

                    // otherwise we do not match
                    return false;
                }

                // Now we need to search for the start of either a path sparator or another wildcard characters 
                // in the pattern
                final int sipat = ipat;

                while(ipat < lpat &&
                      apat[ipat] != STAR &&
                      (apat[ipat] != ESC || ipat < lpat - 1 && apat[ipat + 1] != STAR) &&
                      apat[ipat] != PATHSEP) {
                    ipat++;
                }

                // if we reached the end of the pattern just do a string compare with the corresponding part from 
                // the end of the string
                if(ipat >= lpat) {
                    return checkEnds(sipat, true);
                }

                // If we stopped at an other wildcard
                // we exclude it from being compared
                if(apat[ipat] == STAR) {
                    ipat--;
                }

                // Now we need to check whether the litteral substring of the pattern 
                // is contained in the string somewhere
                final int l = ipat- sipat + 1;
                final int sistr = istr;

                while(istr < lstr && ! strncmp(apat, sipat, astr, istr, l)) istr++;

                if(istr >= lstr) return false;

                add(new String(astr, sistr, istr - sistr));
                ipat++;
                istr += l;
            }

            return match();
        }

