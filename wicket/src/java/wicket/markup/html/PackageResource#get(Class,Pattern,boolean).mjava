	/**
	 * Gets non-localized resources for a given set of criteria. Multiple
	 * resource can be loaded for the same criteria if they match the pattern.
	 * If no resources were found, this method returns null.
	 * 
	 * @param scope
	 *            This argument will be used to get the class loader for loading
	 *            the package resource, and to determine what package it is in.
	 *            Typically this is the calling class/ the class in which you
	 *            call this method
	 * @param pattern
	 *            Regexp pattern to match resources
	 * @param recurse
	 *            Whether this method should recurse into sub packages
	 * @return The resources, never null but may be empty
	 */
	public static PackageResource[] get(Class scope, Pattern pattern, boolean recurse)
	{
		final List<PackageResource> resources = new ArrayList<PackageResource>();
		String packageRef = Strings.replaceAll(PackageName.forClass(scope).getName(), ".", "/")
				.toString();
		ClassLoader loader = scope.getClassLoader();
		try
		{
			// loop through the resources of the package
			Enumeration packageResources = loader.getResources(packageRef);
			while (packageResources.hasMoreElements())
			{
				URL resource = (URL)packageResources.nextElement();
				URLConnection connection = resource.openConnection();
				if (connection instanceof JarURLConnection)
				{
					JarFile jf = ((JarURLConnection)connection).getJarFile();
					scanJarFile(scope, pattern, recurse, resources, packageRef, jf);
				}
				else
				{
					String absolutePath = scope.getResource("").toExternalForm();
					File basedir;
					URI uri;
					try
					{
						uri = new URI(absolutePath);
					}
					catch (URISyntaxException e)
					{
						throw new RuntimeException(e);
					}
					try
					{
						basedir = new File(uri);
					}
					catch (IllegalArgumentException e)
					{
						log.debug("Can't construct the uri as a file: " + absolutePath);
						// if this is throwen then the path is not really a
						// file. but could be a zip.
						String jarZipPart = uri.getSchemeSpecificPart();
						// lowercased for testing if jar/zip, but leave the real
						// filespec unchanged
						String lowerJarZipPart = jarZipPart.toLowerCase();
						int index = lowerJarZipPart.indexOf(".zip");
						if (index == -1)
						{
							index = lowerJarZipPart.indexOf(".jar");
						}
						if (index == -1)
						{
							throw e;
						}

						String filename = jarZipPart.substring(0, index + 4); // 4 =
						// len
						// of
						// ".jar"
						// or
						// ".zip"
						log.debug("trying the filename: " + filename + " to load as a zip/jar.");
						JarFile jarFile = new JarFile(filename, false);
						scanJarFile(scope, pattern, recurse, resources, packageRef, jarFile);
						return resources.toArray(new PackageResource[resources.size()]);
					}
					if (!basedir.isDirectory())
					{
						throw new IllegalStateException("unable to read resources from directory "
								+ basedir);
					}
					addResources(scope, pattern, resources, new StringBuffer(""), basedir, recurse);
				}
			}
		}
		catch (IOException e)
		{
			throw new WicketRuntimeException(e);
		}

		return resources.toArray(new PackageResource[resources.size()]);
	}

